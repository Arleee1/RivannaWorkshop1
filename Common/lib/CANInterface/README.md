# `CANInterface`

## Usage

`CANInterface.h` defines a basic CAN interface capable of sending and receiving CAN structs. Its constructor requires `rd` (the RX pin of the associated CAN transceiver), `td` (the TX pin), and an optional `standby_pin`.

The interface defines virtual methods for handling receipt of each type of CAN struct. For example, the `virtual void handle(ECUMotorCommands *can_struct)` will be called whenever an `ECUMotorCommands` struct is received. By default, all of these methods do nothing. As such, this interface is not intended to be used directly; it should be extended by another class. 

Classes that extend `CANInterface`, such as `SolarCANInterface`, should define handlers for each struct they need to receive. 

Subclasses will inherit the `void send(CANStruct *can_struct)` method to send structs across the bus. The `send` method is capable of sending any [`CANStruct`](../CANStructs/README.md) object. 

Generally, each node on a CAN bus is expected to have its own subclass of `CANInterface`. Currently, each board has its own `CANInterface` for communicating on the main CAN bus. However, for auxiliary CAN buses, such as the two BMS buses and the motor controller bus, new subclasses of `CANInterface` should be created. 

## Implementation

The `CANInterface` implementation uses an `mbed::CAN` object to read and write from the CAN bus. For both sending and receiving CAN messages, `CANInterface` uses the serialization methods generated by [`CANSerializer`](../CANSerializer/README.md). `CANInterface` creates `rx_thread` to constantly read from the CAN bus. When a message is read, the `id` is used to determine the type of the message and then the appropriate `handle` method is called. 
